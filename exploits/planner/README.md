# Planner

## Сервис

Сервис по созданию планировщиков. Уязвимости были заложены в библиотеках `node-fluent-orm` и `randomizerous`. Первая библиотека представляет собой ORM с некорректной фильтрацией фходных данных, вторая библиотека предствляет собой генератор псевдорандомных чисел на основе `LFSR`.

Язык: `js`

База Данных: `mariadb`

Flag places: 

* `additionalInfo` у пользователя, вес - `2/3`
* `description` у  задачи в планировщике, вес - `1/3`

## Первая уязвимость

Первая узявимость заключается в возможности обхода фильтрации ввода данных в ORM. 

В библиотеке `node-fluent-orm` в файле `lib/model.js` реализована функция `makeCorrectValues`, которая вызывается для всех методов, работающих с базой данных, в качетсве фильтра входных параметров, которые в свою очередь берутся из пользовательского ввода.

```js
makeCorrectValues(params) {
    for (let key in params)
        if (typeof(params[key]) == 'string')
            params[key] = `"${this.checking(this.prechecking(params[key])).trim()}"`;
    return params;
}
```

Если посмотреть на конструкцию `this.checking(this.prechecking(params[key])).trim()` , то можно заметить, что последовательно вызывается две функции, одна из которых `checking` :

```js
checking(str) { return str.replace(/[^\w@+-:=. ]/, '') }
```

Из составленного регулярного выражения следует, что в любой строчке заменится первое вхождение символа, не удовлетворяющего этому условию, на пустую строку, что дает возможность обойти данный фильтр всего лишь дублировав первое вхождение запрещенного символа, в нашем случае данным сиволом является `"` , тогда на примере запроса на создание планировщика, можно использовать пэйлоад подобный данному, положив его в поле описания планировщика :

 `planner_descr"", (SELECT GROUP_CONCAT(additionalInfo) FROM users)); -- comment`

Запросом создается новый планировщик с описанием `planner_descr`, а дата создания планировщика будет содержать в себе строку из `additionalInfo ` всех пользователей. 

Закрыть данную уязвимость можно просто добавив ключ `g` , так же как и в функции `precheking`, тогда регулярное выращение будет находить все запрещенные символы и заменять их на пустую строчку.

## Вторая уязвимость

Вторая уязвимость заключалась в генерации куки при авторизации. В файле `src/routes/authenticator.js` используется библиотека `randomizerous` , из которой берется класс `Random`, инициализируется числом `9876543567890876543`, что в последствии позволяет генерировать "рандомные" 4-х байтные hex строчки. В целом выглядит как обычный рандом, и кажется, что смена этого магического числа должна спасти от любых проблем с данным генератором, но... в данной библиотеке используется генератор, основанный на [LFSR](https://en.wikipedia.org/wiki/Linear-feedback_shift_register), это можно понять посмотрев код библиотеки `randomizerous` . В данной реализации библиотеки с помощью сида, посланного при инициализации рандома, создается полином, на основе которого происходит генерация последующих битов, если нам будет известно `2*n` генераций рандома основанного на `LFSR`, то мы сможем найти минимальный полином, который осуществляет генерацию заданной последовательности. Данную задачу нам поможет решить [алгоритм Берлекампа-Месси](https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm). 

В библиотеке начальный стейт равен 1, а максимальная длинна полинома не привышает 32 бит, в силу реализации алгоритма, соответсвенно получив 64 бита генераций, мы можем восстановить полином. В куках используется конкатенация четырех 32-х битных чисел, опять же можно найти в коде библиотери и при непосредственном вызове метода `getHexBytes` из файла `src/routes/authenticator.js` , итого куки содержат 128 бит генераций рандома, чего вполне достаточно для нахождения полинома, генерирующего данную последовательность. Зная начальный стейт генератора и полином, по которому происходит генерация, можно получить все предыдущие и последующие возможные куки.  Данную уязвимость легко заметить, если знать, что в `JavaScript` существует свой генератор рандома `Math.random`. 

Защитой от данной уязвимости может являтся изменение алгоритма внутри самого генератора, либо заменой генерации куки на более безопасную, например используя хэши с солью.