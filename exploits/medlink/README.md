## Первая уязвимость 

 Аутентификация в сервисе осуществлялась посредством куки `medlinkToken`,  генерировал ее вот такой код код из класса SessionSource:

```
public string GetSession()
{
	var secureKeyPart = Utils.GetSha256Bytes(_seed);
	var idPart = BitConverter.GetBytes(_sessions.Id);
	var data = new byte[secureKeyPart.Length + idPart.Length];
	
	Buffer.BlockCopy(secureKeyPart, 0, data, 0, secureKeyPart.Length);
	Buffer.BlockCopy(idPart, 0, data, secureKeyPart.Length, idPart.Length);
	
	_seed = Guid.NewGuid().ToString();
	
	return Convert.ToBase64String(data);
}
```
На первый взгляд он должен генерировать рандомные токены, но это не так. `SessionSource ` инжектится через DI container и для него не вызывается `.SingleInstance()`, поэтому на каждый вызов ручки он создает новый экземпляр этого класса и для каждой сессии secureKeyPart генерируется с seed-ом равным пустой строке, `_sessions.Id `- неубывающий счетчик сессий, состояние которого можно получить из текущей сессии

##  Вторая уязвимость 

PathTraversal. `BodyModelsStorage` внутри себя использует Path.Combine и делает это следующим образом: 
* BodyModelsStorage.Add(BodyModelInfo info) - сохраняет BodyModelInfo в Path.Combine(BodyModelInfo.ModelSeries,  BodyModelInfo.Revision)
* BodyModelsStorage.Get(string series, string revision) - читает BodyModelInfo из Path.Combine(string series, string revision)

Хотя ".." и фильтруются, с помощью Get(string series, string revision) можно вычитать любой файлик с BodyModelInfo, передав вместо revision абсолютный путь, до файлика который нужно украсть, ведь Path.Combine отбросит все аргументы предшуствующие абсолютному пути.  

`BodyModelsStorage.Get("myModelSeries", "/app/medlink/diagnostic/_targetmode_/_targetrevision_");` 