#!/usr/bin/env python3.7
import os
import random
import string
import traceback

import asyncio
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes

from api import API
from ciphers import aes, xor
from ciphers.bb84 import BB84
from protos import get_msg_pb2, logins_pb2, response_pb2, request_pb2, set_msg_pb2, utils_pb2
from utils import Gate, H, Qubit


ALGOS = {
    utils_pb2.Algo.AES: aes,
    utils_pb2.Algo.XOR: xor
}
ALPHA = set(string.printable.encode())
HOSTNAME = 'localhost'


def generate_string(string_length=31):
    alpha = string.ascii_lowercase + string.digits
    return ''.join(random.choice(alpha) for _ in range(string_length)) + '='


def send(bits, gates):
    qubits = []
    for bit, gate in zip(bits, gates):
        qubit = Qubit(bit, 1-bit)
        if gate.value == '+':
            qubits.append(qubit)
        else:
            qubits.append(H(qubit))
    return qubits


def extend_flag_aes(flag):
    return 'This is Ur flag:{}. Do not lose it!'.format(flag)


def extend_flag_xor(flag):
    return 'This is flag:{}. Be careful!'.format(flag)


def generate_request():
    request = request_pb2.Request()

    bits, client_gates = [], []
    for _ in range(1, 280):
        bits.append(float(random.randint(0, 1)))
        client_gates.append(Gate(random.choice('+x')))

    qubits = [x.to_protobuf() for x in send(bits, client_gates)]
    request.qubits.extend(qubits)
    request.gates.extend([x.to_protobuf() for x in client_gates])

    return request, bits, client_gates


async def get_logins(algo, hostname):
    request, bits, client_gates = generate_request()
    request.algo = algo
    request = request.SerializeToString()

    async with API(hostname) as api:
        response = await api.get_logins(request)
    server_gates = list(map(Gate.from_protobuf, response.gates[:]))
    logins = response.option.Extensions[logins_pb2.LOGINS]

    bb84 = BB84()
    key = bb84.generate_key(server_gates, client_gates, bits)

    algo = ALGOS[algo]
    decrypted_logins = []
    for name in logins.name[:]:
        decrypted_logins.append(algo.decrypt(key, name))
    return decrypted_logins


async def set_msg(login, msg, algo, hostname):
    request, bits, client_gates = generate_request()

    request.algo = algo
    request.option.Extensions[set_msg_pb2.SET_MSG_REQUEST].msg = msg
    request.option.Extensions[set_msg_pb2.SET_MSG_REQUEST].login = login
    request = request.SerializeToString()

    async with API(hostname) as api:
        response = await api.set_msg(request)
    server_gates = list(map(Gate.from_protobuf, response.gates[:]))

    bb84 = BB84()
    key = bb84.generate_key(server_gates, client_gates, bits)

    algo = ALGOS[algo]
    set_msg_proto = response.option.Extensions[set_msg_pb2.SET_MSG_RESPONSE]
    decrypted_msg = algo.decrypt(key, set_msg_proto.msg)

    return key, decrypted_msg


async def get_msg(login, algo, hostname):
    request, bits, client_gates = generate_request()

    request.algo = algo
    request.option.Extensions[get_msg_pb2.GET_MSG_REQUEST].login = login
    request = request.SerializeToString()

    async with API(hostname) as api:
        response = await api.get_msg(request)
    server_gates = list(map(Gate.from_protobuf, response.gates[:]))

    bb84 = BB84()
    key = bb84.generate_key(server_gates, client_gates, bits)

    algo = ALGOS[algo]
    get_msg_proto = response.option.Extensions[get_msg_pb2.GET_MSG_RESPONSE]
    decrypted_msg = algo.decrypt(key, get_msg_proto.msg)

    return decrypted_msg


async def put_flag_algo(algo, extend_flag):
    flag = generate_string()
    login, msg = os.urandom(12), extend_flag(flag).encode()

    key, _ = await set_msg(login, msg, algo, HOSTNAME)
    key = long_to_bytes(key)
    return login, flag


async def get_ct_algo(login, algo):
    return await get_msg(login, algo, HOSTNAME)


async def crack_flag_aes():
    algo = utils_pb2.Algo.AES
    login, flag = await put_flag_algo(algo, extend_flag_aes)
    ct = await get_ct_algo(login, algo)
    tmp_iv, tmp_ct = [ct[i:i+16] for i in range(0, len(ct), 16)][2:4]
    tmp_pt = b'. Do not lose it'
    for i in range(0x1000000):
        key = bytes.fromhex(long_to_bytes(i).hex().zfill(32))
        if AES.new(key, iv=tmp_iv, mode=AES.MODE_CBC).decrypt(tmp_ct) == tmp_pt:
            cracked_flag = AES.new(key, iv=ct[:16], mode=AES.MODE_CBC).decrypt(ct[16:])[:32].decode()
            if cracked_flag == flag:
                print('[AES] Cracked!')
            else:
                print('[AES] No way :(')
            return
    print('[AES] This time key is too long. Try more!')

def xor_bytes(a, b):
    return bytes([x^y for x,y in zip(a, b)])

async def crack_flag_xor():
    algo = utils_pb2.Algo.XOR
    login, flag = await put_flag_algo(algo, extend_flag_xor)
    ct = await get_ct_algo(login, algo)
    key_start = xor_bytes(ct[:13], b'This is flag:')	
    key_finish = xor_bytes(ct[45:], b'. Be careful!')
    
    for i in range(len(key_start)):
        if not all(xor_bytes(key_finish[i:], key_start)):
            for j in range(len(key_start)):
                if not all(xor_bytes(key_start[j:], key_finish[:i])):
                    key = (key_start[:j] + key_finish[:i])
                    if xor_bytes(ct, key * 4)[13:45] == flag.encode():
                        print('[XOR] Cracked!')
                        return

    # temp_pt = b'Hey! This is Ur flag:'
    # temp_key = xor_bytes(temp_pt, ct)
    # for i in range(len(temp_key)):
    #     cracked_flag = xor_bytes(ct[len(temp_pt):], temp_key[i:]*3)
    #     if all(x in ALPHA for x in set(cracked_flag)):
    #         if cracked_flag == flag.encode():
    #             print('[AES] Cracked!')
    #             return
    print('[XOR] No way :(')

if __name__ == '__main__':
    # asyncio.run(crack_flag_aes())
    asyncio.run(crack_flag_xor())