Основная уязвимость в том, что при распределении ключа по протоколу BB84 откидывается половина отправленных битов. Т.е. длина ключа `~ 280/2 = 140 бит = 18 байт`.

---

Уязвимости в алгоритмах:
- __AES__

Данные для AES: 

```py
key = bytes.fromhex(hex(key)[2:].zfill(64)[:64])
key, iv = key[:16], key[16:]
```

При такой генерации `key` будет почти весь состоять из нулей. Толкьо последние 0-3 байта будут от распределённого при BB84. 

`IV` полностью рандомный, но не зная его, можно расшифровать всё, кроме 1го блока (флаг в 2-3 блоках)

Расшифровать можно пробрутив недостающую часть ключа:

- __XOR__
 
Ключ XOR'а 15-18 байт (распределённый BB84). Мы знаем первые и последние 13 байт исходного сообщения. XOR происходит с циклическим ключом, поэтому его первую часть можно узнать, поксорив первые 13 байт шифротекста с известным нам открытым текстом, последнюю часть аналогично. Остаётся только склеить по найденным кускам исходный ключи поксорить с шифротекстом.

---

Чтобы закрыться, нужно увеличить количество совпадающих гейтов сервера и клиента, чтобы больше битов совпало, тем самым увеличив длину ключа. 

Легко закрыться, возвращая те же гейты, что и прислал клиент. Тогда все `260 битов = 33 байта` будут использованы в формировании ключа. Ключ у AES будет полностью случайный, а у XOR не хватит длины исходных сообщений, чтобы полностью собрать ключ.

---

Посмотреть на реализацию эксплойта можно [здесь](./cracker.py)